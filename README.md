# Go 通道队列系统

本项目实现了一个多租户队列系统，提供两种不同的队列策略：FIFO（先进先出）和公平（租户特定的轮询调度）。

[README.md](README_en.md)

## 系统架构

### 核心组件

- **队列接口** (`type.go:5-9`): 定义所有队列实现的通用接口
  - `Next() (tenant string, message int)` - 获取下一个消息
  - `Put(tenant string, message int) error` - 向队列添加消息
  - `IsEmpty() bool` - 检查队列是否为空

- **消息结构体** (`type.go:13-16`): 包含租户标识符和顺序消息索引的消息表示

- **生成器函数** (`type.go:18-29`): 生成租户特定顺序消息的工厂函数

### 队列实现

1. **FIFO 队列** (`fifo.go`): 单通道实现，所有消息按严格到达顺序处理
2. **公平队列** (`fair.go`): 多通道实现，按租户进行轮询调度

## 输出格式规范

### 输入模式显示

系统使用以下符号显示输入模式：

- **`+`** (加号): 表示在该步骤中特定租户有写入操作（消息输入）
- **`.`** (点号): 表示在该步骤中特定租户无操作（无消息输入）

**输入模式示例:**
```
t1: ++++++
t2: +...+.
t3: ..+..+
```

这表示：
- 租户 `t1` 有 6 个连续的写入操作
- 租户 `t2` 在第1步和第5步有写入（第2-4步无操作）
- 租户 `t3` 在第3步和第6步有写入

### Next 调用模式显示

系统使用类似符号显示 Next() 调用模式：

- **`+`** (加号): 表示在该步骤中特定租户有读取操作（消息消费）
- **`.`** (点号): 表示在该步骤中特定租户无读取操作

**Next 模式示例:**
```
t1: ++.+.+
t2: .+.+..
t3: ..+..+
```

这显示了消息随时间从队列中消费的情况。

## 步骤概念和步进逻辑

### 步骤定义
**步骤** 代表模拟中的一个离散时间单位，其中：
1. **输入阶段**: 当前步骤的所有消息被添加到队列中
2. **处理阶段**: 进行一次 `Next()` 调用来消费队列中的消息

### 步骤推进逻辑

系统按以下顺序处理步骤：

1. **步骤初始化**: 对于 `exampleSteps` 中的每个步骤，所有消息被添加到队列
2. **消息消费**: 输入后，精确进行一次 `Next()` 调用来获取消息
3. **模式跟踪**: 按租户按步骤跟踪输入和消费模式
4. **视觉对齐**: 输出格式化为垂直对齐所有租户，便于比较

### 步骤特性

- **可变输入大小**: 不同步骤可以有不同数量的消息（0到多个）
- **单步骤多次写入**: 单个租户可以在一个步骤中写入多个消息
- **空步骤**: 某些步骤可能不包含消息（测试队列清空行为）
- **连续处理**: 系统持续处理直到所有消息都被消费

## 示例执行流程

给定 `exampleSteps` 配置：

```go
var exampleSteps = [][]Message{
    {t1, t1, t2},     // 步骤 0: t1 的 2 条消息，t2 的 1 条消息
    {t1, t1},         // 步骤 1: t1 的 2 条消息
    {},               // 步骤 2: 无消息（空步骤）
    {t1, t2, t3},     // 步骤 3: t1、t2、t3 各 1 条消息
    // ... 更多步骤
}
```

系统将：
1. 处理步骤 0: 添加 3 条消息，消费 1 条消息
2. 处理步骤 1: 添加 2 条消息，消费 1 条消息
3. 处理步骤 2: 添加 0 条消息，消费 1 条消息（如果队列不为空）
4. 处理步骤 3: 添加 3 条消息，消费 1 条消息
5. 继续直到所有消息都被消费

## 队列行为差异

### FIFO 队列行为
- 所有消息按严格到达顺序处理
- 无租户优先级
- 单一共享通道

### 公平队列行为
- 租户间轮询调度
- 每个租户有自己的通道
- 处理时间的公平分配
- 防止租户饥饿

## 使用方法

运行模拟：
```bash
go run .
```

这将使用相同的输入模式执行 FIFO 和公平队列实现，允许比较它们的输出行为。